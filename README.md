# 对象与对象之间的关系
## 继承
类与类之间、类与抽象类之间、接口与接口之间  
关键字:extends
## 实现
类与接口之间  
关键字:implements
## 依赖
类A使用了类B，而这种使用关系具有临时性、不确定性、非常弱  
场景:局部变量、方法参数
## 关联
类A与类B之间的强依赖，但是类A与类B是平等的  
场景:类变量
## 聚合
类A与类B之间的强依赖，has-a关系，类A比类B要更大些，类A不维护类B的生命周期  
场景:类A是类B的集合
## 组合
类A与类B之间的强依赖，contains-a关系，类B是类A的一部分，类A维护类B的生命周期  
场景:类变量
# 可维护性与可复用性
## 坏味道的模式
### 过于僵硬
模块与模块之间耦合，加入新功能需要调整太多模块
### 过于脆弱
模块与模块之间耦合，改变一个模块有可能影响其他模块
### 复用率低
不敢碰已有的东西，重新写自己的代码
### 黏度过高
以破坏原始设计意图和原始设计框架的方式进行新需求的处理
## 设计目标
### 可扩展
反面过于僵硬  
方便加入新功能，不影响其他模块  
开-闭原则、里氏代换原则、依赖倒转原则、组合/聚合复用原则
### 灵活性
反面过于脆弱  
允许代码修改，不影响其他模块  
开-闭原则、迪米特法则、接口隔离
### 可插入性
反面黏度过高  
可以很方便的把一个类抽出去，同时将一个具有相同接口的类加入进来  
开-闭原则、里氏代换原则、依赖倒转原则、组合/聚合复用原则
## 可复用性
### 传统的复用
#### 代码的剪贴复用（工具类的复用）
#### 算法的复用
#### 数据结构的复用
### 面向对象设计的复用
#### 面向对象设计
数据的抽象化、继承、封装和多态性是面向对象的语言的重要特性  
数据的抽象化、继承使得概念和定义可以复用  
多态性使得实现和应用可以复用  
数据的抽象化、封装可以保持和促进系统的可维护性  
#### 复用的焦点
含有宏观商业逻辑的抽象层次上  
既然抽象层次是一个应用系统做战略性判断和决定的地方，呢么抽象层次就应当是较为稳定的，应当是复用的重点  
如果抽象层次的模块相对独立于具体层次的模块的话，呢么具体层次内部的变化就不会影响到抽象层次的结构，所以抽象层次的模块的复用就会较为容易  
# 6大原则
## 开闭原则
1. 通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软件系统有一定的适应性和灵活性  
2. 已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性  
### 抽象化是关键
不允许更改的是系统的抽象层，而允许扩展的是系统的实现层
### 对可变性的封装原则
考虑你的设计中什么可能会发生变化。与通常将焦点放到什么会导致设计改变的思考方式正好相反，这一思路考虑的不是什么会导致设计改变，而是考虑你允许什么发生变化而不让这一变化导致重新设计
1. 一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里面  
2. 一种可变性不应当与另一种可变性混合在一起  
## 里氏代换原则
从抽象化到具体化的导出要使用继承关系和这里要引入的里氏代换原则  
基类出现的地方一定可以适应其子类
## 依赖倒转原则
要依赖于抽象，不要依赖于具体  
传统的设计方法倾向于使高层次的模块依赖于低层次的模块
## 接口隔离原则
一个类对另外一个类的依赖性应当是建立在最小的接口上的  
DCI
## 合成/聚合复用原则
一个合成关系中的成分对象是不能与另一个合成关系共享的。一个成分对象在同一时间内只能属于一个合成关系
## 迪米特法则
一个对象应当对其他对象有尽可能少的了解
