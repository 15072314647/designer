# 工厂模式
工厂模式专门负责将大量有共同接口的类实例化，这里的共同接口也可以理解为所做的事情都类似（比如数据库操作的dao接口可以理解为共同接口）；  
一般而言，一个系统总是可以抽象成产品的消费者角色、产品的工厂角色、产品角色三个子系统；在spring框架里，产品的工厂角色就是spring容器本身，产品角色与产品的消费者角色已经你中有我，我中有你了；【理解产品角色与消费者角色消费产品是一个重要的点】
## 简单工厂模式
静态工厂方法模式  
个人觉得spring的BeanFactory就是简单工厂模式的一个实现
### 工厂类角色
商业逻辑在这里
### 抽象产品角色
### 具体产品角色
增加新的产品需要修改工厂类角色
## 工厂方法模式
个人觉得spring的FactoryBean就是工厂方法模式的一个实现
### 抽象工厂角色
### 具体工厂角色
### 抽象产品角色
### 具体产品角色
增加新的产品很容易；客户端直接实例化具体工厂角色
## 抽象工厂模式
考虑如下场景：抽象出第三方接口提供者的BeanFactory（理解父子BeanFactory的概念），系统里有BeanFactory-salA、BeanFactory-salB....，然后根据配置文件决定是使用BeanFactory-salA还是BeanFactory-salB，这个时候使用的就是抽象工厂模式
### 对象的创建模式
### 抽象工厂角色
### 具体工厂角色
### 抽象产品角色
### 具体产品角色
### 使用场景
1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节
2. 这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品
3. 同属于同一个产品族的产品是一起使用的
4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现
### 变化
增加新的产品族，只需要提供新的具体工厂类就行了  
增加新的产品等级结构，就需要修改所有的具体工厂类
